From 0e1cb54c47996e73b33cf23e7dd2394bde0f64f5 Mon Sep 17 00:00:00 2001
From: PeterPan <ajiu9ya@126.com>
Date: Mon, 19 May 2025 06:03:01 -0400
Subject: [PATCH] add udf native tool optimizers

---
 .../huawei/unt/optimizer/ArrayFieldHandler.java    | 83 ++++++++++++++++++
 .../huawei/unt/optimizer/BranchStmtLabeler.java    | 57 +++++++++++++
 .../unt/optimizer/InitStaticReturnHandler.java     | 32 +++++++
 .../java/com/huawei/unt/optimizer/Optimizer.java   |  9 ++
 .../java/com/huawei/unt/optimizer/Optimizers.java  | 38 +++++++++
 .../huawei/unt/optimizer/ReduceTupleOptimizer.java | 98 ++++++++++++++++++++++
 .../huawei/unt/optimizer/RemoveIgnoreClass.java    | 51 +++++++++++
 .../com/huawei/unt/optimizer/RemoveLogger.java     | 54 ++++++++++++
 .../java/com/huawei/unt/optimizer/RemoveTrap.java  | 53 ++++++++++++
 .../huawei/unt/optimizer/StmtGraphAnalyzer.java    | 60 +++++++++++++
 .../unt/optimizer/StringBuilderOptimizer.java      | 64 ++++++++++++++
 .../com/huawei/unt/optimizer/StringPacking.java    | 83 ++++++++++++++++++
 .../unt/optimizer/stmts/OptimizedDirectStmt.java   | 71 ++++++++++++++++
 .../unt/optimizer/stmts/OptimizedJAssignStmt.java  | 76 +++++++++++++++++
 .../unt/optimizer/stmts/OptimizedLinesStmt.java    | 66 +++++++++++++++
 .../huawei/unt/optimizer/stmts/OptimizedValue.java | 67 +++++++++++++++
 16 files changed, 962 insertions(+)
 create mode 100644 src/main/java/com/huawei/unt/optimizer/ArrayFieldHandler.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/BranchStmtLabeler.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/InitStaticReturnHandler.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/Optimizer.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/Optimizers.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/ReduceTupleOptimizer.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/RemoveIgnoreClass.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/RemoveLogger.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/RemoveTrap.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/StmtGraphAnalyzer.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/StringBuilderOptimizer.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/StringPacking.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/stmts/OptimizedDirectStmt.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/stmts/OptimizedJAssignStmt.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/stmts/OptimizedLinesStmt.java
 create mode 100644 src/main/java/com/huawei/unt/optimizer/stmts/OptimizedValue.java

diff --git a/src/main/java/com/huawei/unt/optimizer/ArrayFieldHandler.java b/src/main/java/com/huawei/unt/optimizer/ArrayFieldHandler.java
new file mode 100644
index 0000000..fecddad
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/ArrayFieldHandler.java
@@ -0,0 +1,83 @@
+package com.huawei.unt.optimizer;
+
+import com.huawei.unt.model.MethodContext;
+import com.huawei.unt.optimizer.stmts.OptimizedDirectStmt;
+import com.huawei.unt.optimizer.stmts.OptimizedJAssignStmt;
+import com.huawei.unt.optimizer.stmts.OptimizedValue;
+import com.huawei.unt.translator.TranslatorException;
+import com.huawei.unt.translator.TranslatorUtils;
+import com.huawei.unt.translator.visitor.TranslatorTypeVisitor;
+import com.huawei.unt.translator.visitor.TranslatorValueVisitor;
+import sootup.core.jimple.basic.Local;
+import sootup.core.jimple.basic.Value;
+import sootup.core.jimple.common.ref.JArrayRef;
+import sootup.core.jimple.common.stmt.JAssignStmt;
+import sootup.core.jimple.common.stmt.JInvokeStmt;
+import sootup.core.jimple.common.stmt.Stmt;
+import sootup.core.types.PrimitiveType;
+import sootup.core.types.Type;
+
+public class ArrayFieldHandler implements Optimizer {
+    @Override
+    public boolean fetch(MethodContext methodContext) {
+        return true;
+    }
+
+    @Override
+    public void optimize(MethodContext methodContext) {
+        TranslatorValueVisitor valueVisitor = new TranslatorValueVisitor(methodContext);
+        for (int i = 0; i < methodContext.getStmts().size(); i++) {
+            Stmt stmt = methodContext.getStmts().get(i);
+            if (stmt instanceof JAssignStmt && ((JAssignStmt) stmt).getLeftOp() instanceof JArrayRef) {
+                JArrayRef arrayRef = (JArrayRef) ((JAssignStmt) stmt).getLeftOp();
+                Local base = arrayRef.getBase();
+
+                String res = base.toString() + "->append(" + ((JAssignStmt) stmt).getRightOp().toString() + ")";
+                OptimizedDirectStmt optimizedDirectStmt = new OptimizedDirectStmt(res, stmt);
+
+                methodContext.getStmts().set(i,optimizedDirectStmt);
+
+//                arrayRef.getIndex().accept(valueVisitor);
+//
+//                String left = "(*" + TranslatorUtils.formatLocalName(arrayRef.getBase())
+//                        + ")[" + valueVisitor.toCode() + "]";
+//
+//                valueVisitor.clear();
+//
+//                OptimizedValue leftValue = new OptimizedValue(left, ((JAssignStmt) stmt).getLeftOp());
+//
+//                methodContext.getStmts().set(i, new OptimizedJAssignStmt(leftValue,
+//                        ((JAssignStmt) stmt).getRightOp(), (JAssignStmt)  stmt));
+            }
+            if (stmt instanceof JAssignStmt && ((JAssignStmt) stmt).getRightOp() instanceof JArrayRef) {
+                JArrayRef arrayRef = (JArrayRef) ((JAssignStmt) stmt).getRightOp();
+                String localName = TranslatorUtils.formatLocalName(arrayRef.getBase());
+                arrayRef.getIndex().accept(valueVisitor);
+                String index = valueVisitor.toCode();
+                valueVisitor.clear();
+
+                Type type = arrayRef.getType();
+
+                if (type instanceof PrimitiveType) {
+                    throw new TranslatorException("Array is only support primary type yet");
+                }
+
+                String typeString = TranslatorTypeVisitor.getTypeString(type);
+                String ref = localName + "->get(" + index + ")";
+
+                String rightString = "reinterpret_cast<" + typeString + " *>(" + ref + ")";
+                OptimizedValue rightValue = new OptimizedValue(rightString, arrayRef);
+
+                if (methodContext.getStmts().get(i) instanceof OptimizedJAssignStmt) {
+                    OptimizedJAssignStmt originalStmt = (OptimizedJAssignStmt) methodContext.getStmts().get(i);
+                    Value left = originalStmt.getLeftValue();
+                    JAssignStmt originalAssign = originalStmt.getOriginalStmt();
+                    methodContext.getStmts().set(i, new OptimizedJAssignStmt(left, rightValue, originalAssign));
+                } else {
+                    methodContext.getStmts().set(i, new OptimizedJAssignStmt(((JAssignStmt) stmt).getLeftOp(),
+                            rightValue, (JAssignStmt) stmt));
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/BranchStmtLabeler.java b/src/main/java/com/huawei/unt/optimizer/BranchStmtLabeler.java
new file mode 100644
index 0000000..b78bfdc
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/BranchStmtLabeler.java
@@ -0,0 +1,57 @@
+package com.huawei.unt.optimizer;
+
+import com.huawei.unt.model.MethodContext;
+import sootup.core.jimple.common.stmt.BranchingStmt;
+import sootup.core.jimple.common.stmt.Stmt;
+import sootup.core.model.Body;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class BranchStmtLabeler implements Optimizer {
+    @Override
+    public boolean fetch(MethodContext methodContext) {
+        return true;
+    }
+
+    @Override
+    public void optimize(MethodContext methodContext) {
+        Body body = methodContext.getJavaMethod().getBody();
+
+        List<Stmt> stmts = body.getStmts();
+
+        Map<Stmt, Integer> stmtIndex = new HashMap<>();
+
+        Set<Integer> needLabels = new HashSet<>();
+
+        for (int i = 0; i < stmts.size(); i++) {
+            stmtIndex.put(stmts.get(i), i);
+        }
+
+        Map<Integer, List<Integer>> branches = new HashMap<>();
+
+        for (int i = 0; i < stmts.size(); i++) {
+            Stmt stmt = stmts.get(i);
+            if (stmt.branches()) {
+                List<Stmt> targetBranches = body.getStmtGraph().getBranchTargetsOf((BranchingStmt) stmt);
+                List<Integer> targetList = new ArrayList<>();
+
+                for (Stmt targetStmt : targetBranches) {
+                    Integer index = stmtIndex.get(targetStmt);
+                    needLabels.add(index);
+                    targetList.add(index);
+                }
+
+                branches.put(i, targetList);
+            }
+        }
+
+        methodContext.setLabels(needLabels.stream().sorted().collect(Collectors.toList()));
+        methodContext.setBranches(branches);
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/InitStaticReturnHandler.java b/src/main/java/com/huawei/unt/optimizer/InitStaticReturnHandler.java
new file mode 100644
index 0000000..caa3d7c
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/InitStaticReturnHandler.java
@@ -0,0 +1,32 @@
+package com.huawei.unt.optimizer;
+
+import com.google.common.collect.ImmutableList;
+import com.huawei.unt.model.MethodContext;
+import com.huawei.unt.optimizer.stmts.OptimizedLinesStmt;
+import com.huawei.unt.translator.TranslatorContext;
+import sootup.core.jimple.common.stmt.JReturnVoidStmt;
+import sootup.core.jimple.common.stmt.Stmt;
+
+import java.util.List;
+
+/**
+ * static init return an int constant (1), handle it
+ */
+public class InitStaticReturnHandler implements Optimizer {
+    @Override
+    public boolean fetch(MethodContext methodContext) {
+        return TranslatorContext.STATIC_INIT_FUNCTION_NAME.equals(methodContext.getJavaMethod().getName());
+    }
+
+    @Override
+    public void optimize(MethodContext methodContext) {
+        List<Stmt> stmts = methodContext.getJavaMethod().getBody().getStmts();
+
+        for (int i = 0; i < stmts.size(); i++) {
+            Stmt stmt = stmts.get(i);
+            if (stmt instanceof JReturnVoidStmt) {
+                methodContext.getStmts().set(i, new OptimizedLinesStmt(ImmutableList.of("return 1;"), stmt));
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/Optimizer.java b/src/main/java/com/huawei/unt/optimizer/Optimizer.java
new file mode 100644
index 0000000..2769ffc
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/Optimizer.java
@@ -0,0 +1,9 @@
+package com.huawei.unt.optimizer;
+
+import com.huawei.unt.model.MethodContext;
+
+public interface Optimizer {
+    boolean fetch(MethodContext methodContext);
+
+    void optimize(MethodContext methodContext);
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/Optimizers.java b/src/main/java/com/huawei/unt/optimizer/Optimizers.java
new file mode 100644
index 0000000..10433e1
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/Optimizers.java
@@ -0,0 +1,38 @@
+package com.huawei.unt.optimizer;
+
+import com.google.common.collect.ImmutableList;
+import com.huawei.unt.model.MethodContext;
+import com.huawei.unt.optimizer.stmts.OptimizedLinesStmt;
+import com.huawei.unt.translator.TranslatorContext;
+import sootup.core.jimple.common.stmt.Stmt;
+
+import java.util.Collections;
+import java.util.List;
+
+public class Optimizers {
+    public static List<Optimizer> OPTIMIZERS = ImmutableList.of(
+            new StmtGraphAnalyzer(),
+            new BranchStmtLabeler(),
+            new ReduceTupleOptimizer(),
+            new NewRefOptimizer(),
+//            new RemoveLogger(),
+            new RemoveTrap(),
+            new RemoveIgnoreClass(),
+            new MemoryReleaseOptimizer(TranslatorContext.LIB_INTERFACE_REF),
+//            new StringBuilderOptimizer(),
+            new ArrayFieldHandler(),
+            new StringPacking(),
+            new InitStaticReturnHandler());
+
+    public static void optimize(MethodContext methodContext) {
+        for (Optimizer optimizer : OPTIMIZERS) {
+            if (optimizer.fetch(methodContext)) {
+                optimizer.optimize(methodContext);
+            }
+        }
+    }
+
+    public static Stmt getEmptyOptimizedStmt(Stmt stmt) {
+        return new OptimizedLinesStmt(Collections.emptyList(), stmt);
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/ReduceTupleOptimizer.java b/src/main/java/com/huawei/unt/optimizer/ReduceTupleOptimizer.java
new file mode 100644
index 0000000..ad8f365
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/ReduceTupleOptimizer.java
@@ -0,0 +1,98 @@
+package com.huawei.unt.optimizer;
+
+import com.huawei.unt.model.MethodContext;
+import com.huawei.unt.optimizer.stmts.OptimizedJAssignStmt;
+import com.huawei.unt.optimizer.stmts.OptimizedValue;
+import com.huawei.unt.translator.JavaMethodTranslator;
+import com.huawei.unt.translator.visitor.TranslatorValueVisitor;
+import com.huawei.unt.type.flink.FlinkReduceFunction;
+import org.apache.flink.api.common.functions.ReduceFunction;
+import org.apache.flink.api.java.tuple.Tuple2;
+import sootup.core.jimple.basic.Immediate;
+import sootup.core.jimple.basic.Local;
+import sootup.core.jimple.common.expr.JStaticInvokeExpr;
+import sootup.core.jimple.common.ref.JInstanceFieldRef;
+import sootup.core.jimple.common.ref.JParameterRef;
+import sootup.core.jimple.common.stmt.JAssignStmt;
+import sootup.core.jimple.common.stmt.JIdentityStmt;
+import sootup.core.jimple.common.stmt.JReturnStmt;
+import sootup.core.jimple.common.stmt.Stmt;
+import sootup.core.types.ClassType;
+import sootup.java.core.JavaSootMethod;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+public class ReduceTupleOptimizer implements Optimizer {
+    @Override
+    public boolean fetch(MethodContext methodContext) {
+        return methodContext.getUdfType() instanceof FlinkReduceFunction &&
+                methodContext.getJavaMethod().getReturnType() instanceof ClassType &&
+                ((ClassType) methodContext.getJavaMethod().getReturnType()).getFullyQualifiedName()
+                        .equals(Tuple2.class.getName());
+    }
+
+    @Override
+    public void optimize(MethodContext methodContext) {
+        TranslatorValueVisitor valueVisitor = new TranslatorValueVisitor(methodContext);
+        List<Stmt> stmts = methodContext.getJavaMethod().getBody().getStmts();
+
+        Set<Local> returnLocals = new HashSet<>();
+        Set<Local> paramLocals = new HashSet<>();
+        Set<Local> fieldLocals = new HashSet<>();
+
+        for (Stmt stmt : stmts) {
+            if (stmt instanceof JReturnStmt && ((JReturnStmt) stmt).getOp() instanceof Local) {
+                returnLocals.add((Local) ((JReturnStmt) stmt).getOp());
+            }
+            if (stmt instanceof JIdentityStmt && ((JIdentityStmt) stmt).getRightOp() instanceof JParameterRef) {
+                paramLocals.add(((JIdentityStmt) stmt).getLeftOp());
+            }
+            if (stmt instanceof JAssignStmt &&
+                    ((JAssignStmt) stmt).getLeftOp() instanceof Local &&
+                    ((JAssignStmt) stmt).getRightOp() instanceof JInstanceFieldRef &&
+                    paramLocals.contains(((JInstanceFieldRef) ((JAssignStmt) stmt).getRightOp()).getBase())) {
+                fieldLocals.add((Local) ((JAssignStmt) stmt).getLeftOp());
+            }
+        }
+
+        for (int i = 0; i < stmts.size(); i++) {
+            Stmt stmt = stmts.get(i);
+            if (stmt instanceof JAssignStmt &&
+                    ((JAssignStmt) stmt).getLeftOp() instanceof Local &&
+                    returnLocals.contains(((JAssignStmt) stmt).getLeftOp()) &&
+                    ((JAssignStmt) stmt).getRightOp() instanceof JStaticInvokeExpr &&
+                    ((JStaticInvokeExpr) ((JAssignStmt) stmt).getRightOp()).getMethodSignature().getDeclClassType()
+                            .getFullyQualifiedName().equals(Tuple2.class.getName()) &&
+                    ((JStaticInvokeExpr) ((JAssignStmt) stmt).getRightOp()).getMethodSignature().getName().equals("of")) {
+                List<Immediate> args = ((JStaticInvokeExpr) ((JAssignStmt) stmt).getRightOp()).getArgs();
+                boolean needChange = false;
+                String leftValue;
+                String rightValue;
+                args.get(0).accept(valueVisitor);
+                if (args.get(0) instanceof Local && fieldLocals.contains((Local) args.get(0))) {
+                    needChange = true;
+                    leftValue = valueVisitor.toCode() + "->clone()";
+                } else {
+                    leftValue = valueVisitor.toCode();
+                }
+                valueVisitor.clear();
+                args.get(1).accept(valueVisitor);
+                if (args.get(1) instanceof Local && fieldLocals.contains((Local) args.get(1))) {
+                    needChange = true;
+                    rightValue = valueVisitor.toCode() + "->clone()";
+                } else {
+                    rightValue = valueVisitor.toCode();
+                }
+
+                if (needChange && methodContext.getStmts().get(i) instanceof JAssignStmt) {
+                    String chaneValue = "Tuple2::of(" + leftValue + ", " + rightValue + ")";
+                    OptimizedValue value = new OptimizedValue(chaneValue, ((JAssignStmt) stmt).getRightOp());
+                    methodContext.getStmts().set(i,
+                            new OptimizedJAssignStmt(((JAssignStmt) stmt).getLeftOp(), value, (JAssignStmt) stmt));
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/RemoveIgnoreClass.java b/src/main/java/com/huawei/unt/optimizer/RemoveIgnoreClass.java
new file mode 100644
index 0000000..348e350
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/RemoveIgnoreClass.java
@@ -0,0 +1,51 @@
+package com.huawei.unt.optimizer;
+
+import com.huawei.unt.model.MethodContext;
+import com.huawei.unt.translator.TranslatorContext;
+import sootup.core.jimple.common.expr.AbstractInvokeExpr;
+import sootup.core.jimple.common.stmt.JAssignStmt;
+import sootup.core.jimple.common.stmt.Stmt;
+import sootup.core.types.ClassType;
+
+import java.util.List;
+
+public class RemoveIgnoreClass implements Optimizer {
+
+    @Override
+    public boolean fetch(MethodContext methodContext) {
+        return true;
+    }
+
+    @Override
+    public void optimize(MethodContext methodContext) {
+        List<Stmt> stmts = methodContext.getJavaMethod().getBody().getStmts();
+
+        for (int i = 0; i < stmts.size(); i++) {
+
+            if (stmts.get(i) instanceof JAssignStmt) {
+                JAssignStmt stmt = (JAssignStmt) stmts.get(i);
+
+                if (stmt.getLeftOp().getType() instanceof ClassType &&
+                        TranslatorContext.IGNORED_CLASSES.contains(
+                                ((ClassType) stmt.getLeftOp().getType()).getFullyQualifiedName())) {
+                    methodContext.getStmts().set(i, Optimizers.getEmptyOptimizedStmt(stmt));
+                    continue;
+                }
+
+                if (stmt.getRightOp().getType() instanceof ClassType &&
+                        TranslatorContext.IGNORED_CLASSES.contains(
+                                ((ClassType) stmt.getRightOp().getType()).getFullyQualifiedName())) {
+                    methodContext.getStmts().set(i, Optimizers.getEmptyOptimizedStmt(stmt));
+                    continue;
+                }
+
+                if (stmt.getRightOp() instanceof AbstractInvokeExpr &&
+                        TranslatorContext.IGNORED_CLASSES.contains(((AbstractInvokeExpr) stmt.getRightOp())
+                                .getMethodSignature().getDeclClassType().getFullyQualifiedName())) {
+                    methodContext.getStmts().set(i, Optimizers.getEmptyOptimizedStmt(stmt));
+                    continue;
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/RemoveLogger.java b/src/main/java/com/huawei/unt/optimizer/RemoveLogger.java
new file mode 100644
index 0000000..e2eeb76
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/RemoveLogger.java
@@ -0,0 +1,54 @@
+package com.huawei.unt.optimizer;
+
+import com.google.common.collect.ImmutableSet;
+import com.huawei.unt.model.MethodContext;
+import sootup.core.jimple.basic.Local;
+import sootup.core.jimple.common.ref.JStaticFieldRef;
+import sootup.core.jimple.common.stmt.JAssignStmt;
+import sootup.core.jimple.common.stmt.JInvokeStmt;
+import sootup.core.jimple.common.stmt.Stmt;
+import sootup.core.types.ClassType;
+
+import java.util.Set;
+
+// todo: remove log temp. further will remove this optimizer and add log handler
+public class RemoveLogger implements Optimizer {
+    private static final Set<String> LOG_NAMES = ImmutableSet.of("Logger", "LoggerFactory");
+
+    @Override
+    public boolean fetch(MethodContext methodContext) {
+        return true;
+    }
+
+    @Override
+    public void optimize(MethodContext methodContext) {
+        for (int i = 0; i < methodContext.getStmts().size(); i++) {
+            Stmt stmt = methodContext.getStmts().get(i);
+
+            if (stmt instanceof JAssignStmt &&
+                    ((JAssignStmt) stmt).getLeftOp() instanceof Local &&
+                    ((JAssignStmt) stmt).getLeftOp().getType() instanceof ClassType &&
+                    LOG_NAMES.contains(((ClassType) ((JAssignStmt) stmt).getLeftOp().getType()).getClassName())) {
+                methodContext.getStmts().set(i, Optimizers.getEmptyOptimizedStmt(stmt));
+                methodContext.addRemovedStmt(i);
+                continue;
+            }
+
+            if (stmt instanceof JInvokeStmt && ((JInvokeStmt) stmt).getInvokeExpr().isPresent() &&
+                    LOG_NAMES.contains(((JInvokeStmt) stmt).getInvokeExpr().get().getMethodSignature()
+                            .getDeclClassType().getClassName())) {
+                methodContext.getStmts().set(i, Optimizers.getEmptyOptimizedStmt(stmt));
+                methodContext.addRemovedStmt(i);
+                continue;
+            }
+
+            if (stmt instanceof JAssignStmt &&
+                    ((JAssignStmt) stmt).getLeftOp() instanceof JStaticFieldRef &&
+                    ((JAssignStmt) stmt).getLeftOp().getType() instanceof ClassType &&
+                    LOG_NAMES.contains(((ClassType) ((JAssignStmt) stmt).getLeftOp().getType()).getClassName())) {
+                methodContext.getStmts().set(i, Optimizers.getEmptyOptimizedStmt(stmt));
+                methodContext.addRemovedStmt(i);
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/RemoveTrap.java b/src/main/java/com/huawei/unt/optimizer/RemoveTrap.java
new file mode 100644
index 0000000..500b4fc
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/RemoveTrap.java
@@ -0,0 +1,53 @@
+package com.huawei.unt.optimizer;
+
+import com.huawei.unt.model.JavaTrap;
+import com.huawei.unt.model.MethodContext;
+import sootup.core.graph.BasicBlock;
+import sootup.core.graph.StmtGraph;
+import sootup.core.jimple.basic.Trap;
+import sootup.core.jimple.common.stmt.Stmt;
+import sootup.core.util.printer.BriefStmtPrinter;
+
+import java.util.ArrayList;
+import java.util.List;
+
+// todo: delete trap code now. further will remove this optimizer and add trap handler
+public class RemoveTrap implements Optimizer{
+    @Override
+    public boolean fetch(MethodContext methodContext) {
+        return true;
+    }
+
+    @Override
+    public void optimize(MethodContext methodContext) {
+        StmtGraph<?> graph = methodContext.getJavaMethod().getBody().getStmtGraph();
+        List<Stmt> stmts = methodContext.getJavaMethod().getBody().getStmts();
+
+        BriefStmtPrinter stmtPrinter = new BriefStmtPrinter();
+        stmtPrinter.buildTraps(graph);
+        Iterable<Trap> traps = stmtPrinter.getTraps();
+
+        for (Trap trap : traps) {
+            Stmt handleStmt = trap.getHandlerStmt();
+
+            BasicBlock<?> block = graph.getBlockOf(handleStmt);
+
+            for (Stmt stmt : block.getStmts()) {
+                methodContext.getStmts().set(stmts.indexOf(stmt), Optimizers.getEmptyOptimizedStmt(stmt));
+                methodContext.addRemovedStmt(stmts.indexOf(stmt));
+            }
+
+        }
+
+
+        List<JavaTrap> javaTraps = new ArrayList<>();
+        for (Trap trap : traps) {
+            javaTraps.add(new JavaTrap(
+                    trap.getExceptionType(),
+                    stmts.indexOf(trap.getBeginStmt()),
+                    stmts.indexOf(trap.getEndStmt()),
+                    stmts.indexOf(trap.getHandlerStmt())));
+
+        }
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/StmtGraphAnalyzer.java b/src/main/java/com/huawei/unt/optimizer/StmtGraphAnalyzer.java
new file mode 100644
index 0000000..20b733c
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/StmtGraphAnalyzer.java
@@ -0,0 +1,60 @@
+package com.huawei.unt.optimizer;
+
+import com.huawei.unt.model.JavaTrap;
+import com.huawei.unt.model.MethodContext;
+import sootup.core.graph.StmtGraph;
+import sootup.core.jimple.basic.Local;
+import sootup.core.jimple.basic.Trap;
+import sootup.core.jimple.common.stmt.Stmt;
+import sootup.core.util.printer.BriefStmtPrinter;
+import sootup.interceptors.LocalLivenessAnalyser;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class StmtGraphAnalyzer implements Optimizer {
+    @Override
+    public boolean fetch(MethodContext methodContext) {
+        // all method need analyze
+        return true;
+    }
+
+    @Override
+    public void optimize(MethodContext methodContext) {
+        StmtGraph<?> graph = methodContext.getJavaMethod().getBody().getStmtGraph();
+        List<Stmt> stmts = methodContext.getJavaMethod().getBody().getStmts();
+
+        // analyzeLiveLocal
+        LocalLivenessAnalyser localLivenessAnalyser = new LocalLivenessAnalyser(graph);
+
+        Map<Integer, Set<Local>> beforeLocals = new HashMap<>();
+        Map<Integer, Set<Local>> afterLocals = new HashMap<>();
+
+        for (int i = 0; i <stmts.size(); i++) {
+            beforeLocals.put(i, localLivenessAnalyser.getLiveLocalsBeforeStmt(stmts.get(i)));
+            afterLocals.put(i, localLivenessAnalyser.getLiveLocalsAfterStmt(stmts.get(i)));
+        }
+
+        methodContext.setBeforeLocals(beforeLocals);
+        methodContext.setAfterLocals(afterLocals);
+
+        // todo : analyzeTryCatch
+//        BriefStmtPrinter stmtPrinter = new BriefStmtPrinter();
+//        stmtPrinter.buildTraps(graph);
+//        Iterable<Trap> traps = stmtPrinter.getTraps();
+//
+//        List<JavaTrap> javaTraps = new ArrayList<>();
+//        for (Trap trap : traps) {
+//            javaTraps.add(new JavaTrap(
+//                    trap.getExceptionType(),
+//                    stmts.indexOf(trap.getBeginStmt()),
+//                    stmts.indexOf(trap.getEndStmt()),
+//                    stmts.indexOf(trap.getHandlerStmt())));
+//
+//        }
+//        methodContext.setTraps(javaTraps);
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/StringBuilderOptimizer.java b/src/main/java/com/huawei/unt/optimizer/StringBuilderOptimizer.java
new file mode 100644
index 0000000..56a104a
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/StringBuilderOptimizer.java
@@ -0,0 +1,64 @@
+//package com.huawei.unt.optimizer;
+//
+//import com.google.common.collect.ImmutableList;
+//import com.huawei.unt.model.MethodContext;
+//import com.huawei.unt.optimizer.stmts.OptimizedLinesStmt;
+//import com.huawei.unt.translator.visitor.TranslatorValueVisitor;
+//import sootup.core.jimple.basic.Local;
+//import sootup.core.jimple.common.expr.JVirtualInvokeExpr;
+//import sootup.core.jimple.common.stmt.JAssignStmt;
+//import sootup.core.jimple.common.stmt.Stmt;
+//import sootup.core.signatures.MethodSignature;
+//
+//import java.util.List;
+//
+//public class StringBuilderOptimizer implements Optimizer {
+//
+//    private static final String STRING_BUILDER_CLASS = StringBuilder.class.getName();
+//    private static final String APPEND_METHOD_NAME = "append";
+//
+//    @Override
+//    public boolean fetch(MethodContext methodContext) {
+//        for (Stmt stmt : methodContext.getStmts()) {
+//            if (isStringBuilderAppend(stmt)) {
+//                return true;
+//            }
+//        }
+//        return false;
+//    }
+//
+//    @Override
+//    public void optimize(MethodContext methodContext) {
+//        List<Stmt> stmts = methodContext.getStmts();
+//
+//        for (int i = 0; i < stmts.size(); i++) {
+//            if (isStringBuilderAppend(stmts.get(i))) {
+//                JAssignStmt stmt = (JAssignStmt) methodContext.getStmts().get(i);
+//                Local returnLocal = (Local) stmt.getLeftOp();
+//                Local baseLocal = ((JVirtualInvokeExpr) stmt.getRightOp()).getBase();
+//                methodContext.mergeLocals(returnLocal, baseLocal);
+//
+//                // replace stmt
+//                TranslatorValueVisitor valueVisitor = new TranslatorValueVisitor(methodContext);
+//                stmt.getRightOp().accept(valueVisitor);
+//                methodContext.getStmts().set(i, new OptimizedLinesStmt(ImmutableList.of(valueVisitor.toCode() + ";"), stmt));
+//            }
+//        }
+//    }
+//
+//    private boolean isStringBuilderAppend(Stmt stmt) {
+//        if (stmt instanceof JAssignStmt) {
+//            JAssignStmt assignStmt = (JAssignStmt) stmt;
+//
+//            if (assignStmt.getLeftOp() instanceof Local
+//                    && assignStmt.getRightOp() instanceof JVirtualInvokeExpr) {
+//                MethodSignature methodSignature = ((JVirtualInvokeExpr) assignStmt.getRightOp()).getMethodSignature();
+//
+//                return methodSignature.getDeclClassType().toString().equals(STRING_BUILDER_CLASS)
+//                        && methodSignature.getName().equals(APPEND_METHOD_NAME);
+//            }
+//        }
+//
+//        return false;
+//    }
+//}
diff --git a/src/main/java/com/huawei/unt/optimizer/StringPacking.java b/src/main/java/com/huawei/unt/optimizer/StringPacking.java
new file mode 100644
index 0000000..ad836e4
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/StringPacking.java
@@ -0,0 +1,83 @@
+package com.huawei.unt.optimizer;
+
+import com.google.common.collect.ImmutableList;
+import com.huawei.unt.model.MethodContext;
+import com.huawei.unt.optimizer.stmts.OptimizedJAssignStmt;
+import com.huawei.unt.optimizer.stmts.OptimizedLinesStmt;
+import com.huawei.unt.optimizer.stmts.OptimizedValue;
+import com.huawei.unt.translator.TranslatorContext;
+import com.huawei.unt.translator.visitor.TranslatorValueVisitor;
+import sootup.core.jimple.basic.Immediate;
+import sootup.core.jimple.common.constant.StringConstant;
+import sootup.core.jimple.common.expr.AbstractInvokeExpr;
+import sootup.core.jimple.common.expr.JVirtualInvokeExpr;
+import sootup.core.jimple.common.stmt.JAssignStmt;
+import sootup.core.jimple.common.stmt.JInvokeStmt;
+import sootup.core.jimple.common.stmt.Stmt;
+import sootup.core.jimple.visitor.AbstractValueVisitor;
+import sootup.core.signatures.MethodSignature;
+import sootup.core.types.ClassType;
+import sootup.core.types.Type;
+import sootup.java.core.JavaIdentifierFactory;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+public class StringPacking implements Optimizer {
+    private static final ClassType STRING_CLASS_TYPE =
+            JavaIdentifierFactory.getInstance().getClassType(String.class.getName());
+    private static final ClassType OBJECT_CLASS_TYPE =
+            JavaIdentifierFactory.getInstance().getClassType(Object.class.getName());
+    @Override
+    public boolean fetch(MethodContext methodContext) {
+        return true;
+    }
+
+    @Override
+    public void optimize(MethodContext methodContext) {
+        List<Stmt> stmts = methodContext.getJavaMethod().getBody().getStmts();
+        TranslatorValueVisitor valueVisitor = new TranslatorValueVisitor(methodContext);
+        for (int i = 0; i < stmts.size(); i++) {
+            Stmt stmt = stmts.get(i);
+
+            if (stmt instanceof JAssignStmt &&
+                    (((JAssignStmt) stmt).getLeftOp().getType().equals(STRING_CLASS_TYPE) ||
+                            ((JAssignStmt) stmt).getLeftOp().getType().equals(OBJECT_CLASS_TYPE)) &&
+                    ((((JAssignStmt) stmt).getRightOp() instanceof StringConstant) ||
+                            (((JAssignStmt) stmt).getRightOp() instanceof JVirtualInvokeExpr &&
+                                    isToStringFunction((JVirtualInvokeExpr) ((JAssignStmt) stmt).getRightOp())))) {
+                ((JAssignStmt) stmt).getRightOp().accept(valueVisitor);
+                String stringCode = valueVisitor.toCode();
+                valueVisitor.clear();
+
+                ((JAssignStmt) stmt).getLeftOp().accept(valueVisitor);
+                String leftCode = valueVisitor.toCode();
+                valueVisitor.clear();
+
+
+                String rightCode = "new String(" + stringCode + ")";
+
+                OptimizedValue rightValue = new OptimizedValue(rightCode, ((JAssignStmt) stmt).getLeftOp());
+
+                Stmt needChangeStmt = methodContext.getStmts().get(i);
+                if (needChangeStmt instanceof JAssignStmt) {
+                    methodContext.getStmts().set(i,
+                            new OptimizedJAssignStmt(((JAssignStmt) stmt).getLeftOp(), rightValue, (JAssignStmt) stmt));
+                } else if (needChangeStmt instanceof OptimizedJAssignStmt) {
+                    OptimizedJAssignStmt optStmt = (OptimizedJAssignStmt) needChangeStmt;
+                    methodContext.getStmts().set(i,
+                            new OptimizedJAssignStmt(optStmt.getLeftValue(), rightValue, (JAssignStmt) stmt));
+                }
+//                else {
+//                    String codeLine = leftCode + " = " + rightCode + ";";
+//                    methodContext.getStmts().set(i, new OptimizedLinesStmt(ImmutableList.of(codeLine), stmt));
+//                }
+            }
+        }
+    }
+
+    private static boolean isToStringFunction(JVirtualInvokeExpr expr) {
+        return expr.getArgCount() == 0 && expr.getMethodSignature().getName().equals("toString");
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedDirectStmt.java b/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedDirectStmt.java
new file mode 100644
index 0000000..2c6296f
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedDirectStmt.java
@@ -0,0 +1,71 @@
+package com.huawei.unt.optimizer.stmts;
+
+
+import sootup.core.jimple.basic.JimpleComparator;
+import sootup.core.jimple.basic.StmtPositionInfo;
+import sootup.core.jimple.common.stmt.AbstractStmt;
+import sootup.core.jimple.common.stmt.Stmt;
+import sootup.core.jimple.visitor.StmtVisitor;
+import sootup.core.util.printer.StmtPrinter;
+
+import javax.annotation.Nonnull;
+import java.util.Objects;
+
+/*
+    The optimizer returns the result directly.
+ */
+public class OptimizedDirectStmt extends AbstractStmt {
+    private final Stmt originalStmt;
+    private final String optimizedRes;
+
+    public OptimizedDirectStmt(String optimizedRes, Stmt originalStmt){
+        super(originalStmt.getPositionInfo());
+        this.originalStmt = originalStmt;
+        this.optimizedRes = optimizedRes;
+    }
+
+    public String getOptimizedRes(){
+        return optimizedRes;
+    }
+
+    public Stmt getOriginalStmt(){
+        return originalStmt;
+    }
+
+    @Override
+    public boolean fallsThrough() {
+        return originalStmt.fallsThrough();
+    }
+
+    @Override
+    public boolean branches() {
+        return originalStmt.branches();
+    }
+
+    @Override
+    public void toString(@Nonnull StmtPrinter stmtPrinter) {
+        stmtPrinter.literal(optimizedRes);
+    }
+
+    @Override
+    public int equivHashCode() {
+        return Objects.hash(originalStmt,optimizedRes);
+    }
+
+    @Override
+    public boolean equivTo(Object o, @Nonnull JimpleComparator jimpleComparator) {
+        if (!(o instanceof OptimizedDirectStmt)){
+            return false;
+        }
+
+        OptimizedDirectStmt other = (OptimizedDirectStmt) o;
+        return jimpleComparator.caseStmt(originalStmt, other.originalStmt)
+                && optimizedRes.equals(other.optimizedRes);
+    }
+
+    @Override
+    public <X extends StmtVisitor> StmtVisitor accept(@Nonnull X v) {
+        v.defaultCaseStmt(this);
+        return v;
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedJAssignStmt.java b/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedJAssignStmt.java
new file mode 100644
index 0000000..a134e0b
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedJAssignStmt.java
@@ -0,0 +1,76 @@
+package com.huawei.unt.optimizer.stmts;
+
+import sootup.core.jimple.basic.JimpleComparator;
+import sootup.core.jimple.basic.Value;
+import sootup.core.jimple.common.stmt.AbstractStmt;
+import sootup.core.jimple.common.stmt.JAssignStmt;
+import sootup.core.jimple.visitor.StmtVisitor;
+import sootup.core.util.printer.StmtPrinter;
+
+import javax.annotation.Nonnull;
+import java.util.Objects;
+
+public class OptimizedJAssignStmt extends AbstractStmt {
+
+    private final Value leftValue;
+    private final Value rightValue;
+    public final JAssignStmt originalStmt;
+
+    public OptimizedJAssignStmt(@Nonnull Value leftValue, @Nonnull Value rightValue, @Nonnull JAssignStmt originalStmt) {
+        super(originalStmt.getPositionInfo());
+        this.leftValue = leftValue;
+        this.rightValue = rightValue;
+        this.originalStmt = originalStmt;
+    }
+
+    public Value getLeftValue() {
+        return leftValue;
+    }
+
+    public Value getRightValue() {
+        return rightValue;
+    }
+
+    public JAssignStmt getOriginalStmt() {
+        return originalStmt;
+    }
+
+    @Override
+    public boolean fallsThrough() {
+        return originalStmt.fallsThrough();
+    }
+
+    @Override
+    public boolean branches() {
+        return originalStmt.branches();
+    }
+
+    @Override
+    public void toString(@Nonnull StmtPrinter stmtPrinter) {
+        stmtPrinter.literal(leftValue.toString());
+        stmtPrinter.literal(" = ");
+        stmtPrinter.literal(rightValue.toString());
+    }
+
+    @Override
+    public int equivHashCode() {
+        return Objects.hash(originalStmt, leftValue, rightValue);
+    }
+
+    @Override
+    public boolean equivTo(Object o, @Nonnull JimpleComparator jimpleComparator) {
+        if (!(o instanceof OptimizedJAssignStmt)) {
+            return false;
+        }
+
+        OptimizedJAssignStmt other = (OptimizedJAssignStmt) o;
+        return Objects.equals(this.leftValue, other.leftValue) &&
+                Objects.equals(this.rightValue, other.rightValue) &&
+                jimpleComparator.caseAssignStmt(this.originalStmt, other.originalStmt);
+    }
+
+    public <V extends StmtVisitor> V accept(@Nonnull V v) {
+        v.defaultCaseStmt(this);
+        return v;
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedLinesStmt.java b/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedLinesStmt.java
new file mode 100644
index 0000000..6f51a4d
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedLinesStmt.java
@@ -0,0 +1,66 @@
+package com.huawei.unt.optimizer.stmts;
+
+import sootup.core.jimple.basic.JimpleComparator;
+import sootup.core.jimple.common.stmt.AbstractStmt;
+import sootup.core.jimple.common.stmt.Stmt;
+import sootup.core.jimple.visitor.StmtVisitor;
+import sootup.core.util.printer.StmtPrinter;
+
+import javax.annotation.Nonnull;
+import java.util.List;
+import java.util.Objects;
+
+import static com.huawei.unt.translator.TranslatorContext.NEW_LINE;
+
+
+public class OptimizedLinesStmt extends AbstractStmt {
+
+    private final Stmt originalStmt;
+    private final List<String> optimizedCodes;
+
+    public OptimizedLinesStmt(@Nonnull List<String> optimizedCodes, @Nonnull Stmt originalStmt) {
+        super(originalStmt.getPositionInfo());
+        this.originalStmt = originalStmt;
+        this.optimizedCodes = optimizedCodes;
+    }
+
+    public List<String> getOptimizedCodes() {
+        return optimizedCodes;
+    }
+
+    @Override
+    public boolean fallsThrough() {
+        return originalStmt.fallsThrough();
+    }
+
+    @Override
+    public boolean branches() {
+        return originalStmt.branches();
+    }
+
+    @Override
+    public void toString(@Nonnull StmtPrinter stmtPrinter) {
+        optimizedCodes.forEach(code -> stmtPrinter.literal(code + NEW_LINE));
+    }
+
+    @Override
+    public int equivHashCode() {
+        return Objects.hash(originalStmt, optimizedCodes);
+    }
+
+    @Override
+    public boolean equivTo(Object o, @Nonnull JimpleComparator jimpleComparator) {
+        if (!(o instanceof OptimizedLinesStmt)) {
+            return false;
+        }
+
+        OptimizedLinesStmt other = (OptimizedLinesStmt) o;
+        return jimpleComparator.caseStmt(originalStmt, other.originalStmt)
+                && optimizedCodes.equals(other.optimizedCodes);
+    }
+
+    public <V extends StmtVisitor> V accept(@Nonnull V v) {
+        v.defaultCaseStmt(this);
+        return v;
+    }
+}
diff --git a/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedValue.java b/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedValue.java
new file mode 100644
index 0000000..544361d
--- /dev/null
+++ b/src/main/java/com/huawei/unt/optimizer/stmts/OptimizedValue.java
@@ -0,0 +1,67 @@
+package com.huawei.unt.optimizer.stmts;
+
+import com.google.common.base.Objects;
+import sootup.core.jimple.basic.JimpleComparator;
+import sootup.core.jimple.basic.Value;
+import sootup.core.jimple.visitor.ValueVisitor;
+import sootup.core.types.Type;
+import sootup.core.util.printer.StmtPrinter;
+
+import javax.annotation.Nonnull;
+import java.util.stream.Stream;
+
+public class OptimizedValue implements Value {
+
+    private final String optimizedString;
+    private final Value originalValue;
+
+    public OptimizedValue(@Nonnull String optimizedString, @Nonnull Value optimizedValue) {
+        this.optimizedString = optimizedString;
+        this.originalValue = optimizedValue;
+    }
+
+    public String getCode() {
+        return optimizedString;
+    }
+
+    public Value getOriginalValue() {
+        return originalValue;
+    }
+
+    @Nonnull
+    @Override
+    public Stream<Value> getUses() {
+        return originalValue.getUses();
+    }
+
+    @Nonnull
+    @Override
+    public Type getType() {
+        return originalValue.getType();
+    }
+
+    @Override
+    public void toString(@Nonnull StmtPrinter stmtPrinter) {
+        stmtPrinter.literal(optimizedString);
+    }
+
+    @Override
+    public int equivHashCode() {
+        return Objects.hashCode(originalValue, optimizedString);
+    }
+
+    @Override
+    public boolean equivTo(Object o, @Nonnull JimpleComparator jimpleComparator) {
+        if (!(o instanceof OptimizedValue)) {
+            return false;
+        }
+
+        OptimizedValue other = (OptimizedValue) o;
+        return other.getCode().equals(this.getCode()) &&
+                other.getOriginalValue().equivTo(this.getOriginalValue());
+    }
+
+    public void accept(@Nonnull ValueVisitor v) {
+        v.defaultCaseValue(this);
+    }
+}
-- 
1.8.3.1

